# Building a Route Optimization Engine in 5 Hours: An LLM-Assisted Hackathon Post-Mortem

Here's what a route optimization engine looks like at hour 1, hour 3,
hour 6, and demo time. We built this in 8 hours with GitHub Copilot
(running the **Claude Sonnet 4.5 LLM** with GitHub Copilot in IntelliJ)
as the third member in our mob programming team.

![Hour 3](images/route-planning-opti-1445.png)

By using strict constraints and safeguards around our chosen AI coding
agent, we were able to ship a working route optimizer in 4.5 hours that:
\* performs real-time simulated assignments with driver names and
booking IDs \* calculates distances and ETA estimates using the AWS
Location Service API \* provides a planning dashboard

## Setting the Scene: The Hackathon Brief

A coworker and I chose the hackathon brief to put together a route
planning and optimization engine. Given the time constraints, we decided
to think as our coworkers in the route planning department and dream up
how the engine would work in practice. My coworker is one part
full-stack, several sharp parts platform/infrastructure, I'm the
full-stack engineer.

### Before the Hackathon: Initial Prompting

I got us set up in GitHub.

![Prompting the Repo Creation](images/setting_up_repo.png)

... while my trusty coworker set up the initial build. Pretty
impressive, he reported that it took about 90 minutes to achieve this.

![Initial Project Structure](images/initial_build.png)

## Starting Out: Constraint Design

**Initial prompt when creating repository in GitHub**

    I want to build a route Planning & optimization Engine.
    The user stories are:
    - a planner that assigns travellers to vehicles
    - creates pickup/dropoff sequences
    - identifies travellers who cannot be served based on hardcoded constraints

    Set up the project with the following:
    - Java 25
    - Maven
    - Postgres
    - Kafka
    - Lombok
    - Unit tests
    - GitHub Actions
    - AWS integration
    - CI/CD with AWS EKS
    - Helm
    - Terraform
    - Dockerfile

**The main prompt before starting the hackathon**

    Mission:
    This is to build a prototype for a hackathon. We have 8 hours.
    We are a team of 2 people - one fullstack engineer and one Platform/DevOps engineer.

    This is our brief:
    Route Planning & Optimization Engine
    Build a planner that assigns travellers to vehicles, creates pickup/dropoff sequences and identifies 
    travellers who cannot be served based on constraints chosen by the team.
    We've already generated the shell with GitHub.com Copilot for frontend and backend in vanilla HTML + JavaScript 
    and Spring Boot, respectively.

    Our goal is to produce a working prototype within 8 hours that we can present at the end-of-day demo. We just need 
    it to be working, code quality or architecture isn't so important.

    This is what we want to achieve before 2pm today:
    Frontend:
    •   Admin dashboard view
    •   Map with mock car/customer positions
    •   List of assignments
    •   "Optimize routes" button that triggers backend

    Backend:
    •   Simple assignment endpoint
    •   Algorithm (closest driver to customer)
    •   Mock data response
    •   one AWS Bedrock integration for show

    Way of Working
    We drive, you execute.
    You don't make architectural or design decisions without our express written confirmation.
    Small, focused edits in non-contiguous blocks of max 5 lines in one file only. No multi-file changes simultaneously.
    No shortcuts, ugly hacks, workarounds, or "getting things to work." Always offer an execution plan if we can't resolve 
    a bug and you always defer to us for the final decision on how to resolve something. We have veto power.
    You work autonomously only when we specify with express written confirmation. Always assume that you will get 
    confirmation from us.

The way of working is critical here. I've been refining this technique
over the last period, as I've been burned by the simultaneously
overconfident and then overly obsequious apologies. When it all comes
crashing down after a botched change or filesystem change. This overtly
clear tone and these demarcations have proven lately to at least jolt
the agent to register that we are not going to be vacant at the wheel.
By keeping the prompts tight and the scope narrow, we were able to
maintain control over the development process.

**First coding task upon repository creation**

    Set up a hello word endpoint /alive with Spring Boot

## Building the Engine

What follows are annotated screenshots and some of the key decisions and
tradeoffs we made at each timestamp.

### Hour 1: Basic Endpoint + Frontend Setup

![Hour 1](images/route-planning-opti-1035.png)

Here, we moved away from the initial concept of a A-to-B route planner,
reminiscient of a consumer app, to a design that would be more familiar
to a route planning operations team. This meant a dashboard view with a
map, a list of drivers and travellers, and an "optimize routes" button.

The initial plotting of drivers and orders looked odd. We jostled with
Copilot to get it to spread the markers out a bit more.

### Hour 2: Basic Assignment Logic

![Hour 2](images/route-planning-opti-1103.png)

At this point, Copilot wasn't able to understand our requests to spread
out the markers against the boundaries of Stockholm county. So, we
needed to manually provide a publicly-available JSON files with the
dimensions for Stockholm county and get more explicit about the
randomization logic. This screenshot shows the first iteration of the
better spread, zoomed in a little.

Screencast: (click to watch) [![Demo
Video](images/before-aws-tn.png){width="640"}](https://projects.minademian.com/docs-lib/before-aws-locserv.mp4)

### Hour 2: AWS Location Service Integration

![Hour 2 AWS Location
Service](images/prompt_to_amazon-location-service-screenshot.png)

From this terse prompt and then attaching a direct link to the AWS
documentation, Copilot was able to implement the route calculation and
rendering on the map... with no errors.

Screencast: (click to watch) [![Demo
Video](images/after-prompt-tn.png){width="640"}](https://projects.minademian.com/docs-lib/after-prompt.mp4)

I'm not a high-fiver, but there were reports of high-fiving and
fist-bumping in the room. Copilot shone here. No hiccups, no errors,
just straight-up working code.

### Hour 2: Tweaking Frontend

![Hour 2 Frontend](images/route-planning-opti-1115.png)

The richness of the icons initially selected were making the map both
cluttered and difficult to read. The map was also chugging when
rendering. We instructed Copilot to pick simpler, sleeker icons, and
relied on color rather than iconography to differentiate drivers from
travellers. We saw an immediate performance improvement and saw how the
UX worked better.

### Just Before Demo: More Complex Logic + Data Structures

The demo session happened earlier than expected, so we had to stop here.
We wanted to go the extra mile and deploy this with the boilerplate EKS
code generated by Copilot, but it would have been a stretch and we chose
to leave it on the development machine.

Screencast: (click to watch) [![Demo
Video](images/final-tn.png){width="640"}](https://projects.minademian.com/docs-lib/route-planning.mp4)

## Reflections and Analysis

This is not a hyperbolic take on using a coding agent nor is it a
hitpiece. There were some real highlights, like when we instructed
Copilot to switch to streetmaps instead of satellite view, and it
switched to another map provider by itself. And of course, the route
planner integration with AWS Location Service was flawless.

A strong firm hand kept us out of loops and watching the output - both
in the browser and in the IDE - made all the difference. We were able to
catch small mistakes early and course-correct before they compounded
into larger issues.
